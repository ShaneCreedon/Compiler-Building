/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. AssignmentTwo.jj */
/*@egen*//* Shane Creedon 
 * Student ID: 15337356
 * Module: CA4003 Compiler Construction Assignment 2
 * @David Sinclair: Please use this version of my code as my final edition.
 */

// Options for Lexer and Parser
options {
	JAVA_UNICODE_ESCAPE = true;
	IGNORE_CASE = true;

	           
	             
	                         
}

// Define Parser Scope
PARSER_BEGIN(AssignmentTwo)

	import java.io.*;
	import java.util.*;
	
	// Main class for passing in CAL code.
	class AssignmentTwo/*@bgen(jjtree)*/implements AssignmentTwoTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTAssignmentTwoState jjtree = new JJTAssignmentTwoState();

/*@egen*/

		public static STC ST = new STC();
		public static String scope = "global";
		
		public static void main(String[] args) throws FileNotFoundException {
			
			if(args.length < 1) {		
				System.out.println("Please pass in the filename.");
				System.exit(1);
			}
			
			try {	
				// parser initialisation
				AssignmentTwo parser = new AssignmentTwo(new FileInputStream(args[0]));

				// Build our Abstract Syntax tree (AST)
				SimpleNode root = parser.program();
				System.out.println("Abstract Syntax Tree:");
				root.dump(" ");

				// Output the symbol table of the program based off the input
				System.out.println();
				System.out.println("Symbol Table:\n"); 
				ST.print();

				// Perform Type checking & Semantic Analysis on the program.
				// If an error/warning is found, it will be reported in the terminal.
				System.out.println();
				System.out.println("Type Checking...");
				TypeCheckVisitor tc = new TypeCheckVisitor();
				root.jjtAccept(tc, ST); 

				/* Perform IR representation conversion
				 * Goal: Traverse the AST and generate appropriate IR
				 * code from each node.
				 * Output will be stored in .ir files
				 * Output filename will be generated from input .cal file passed
				 * in via the command line.
				 * We will be using 3-address code.
				 */
				String fileName = args[0].substring(0, args[0].indexOf(".")) + ".ir";
				System.out.println("\n----------------------------------------");
				System.out.println("Intermediate Representation Generation: ");
				System.out.println("IR code will be generated into: \'" + fileName);
			
				try {
					PrintStream outputStream = new PrintStream(new FileOutputStream(fileName));
					// Reassign standard input stream to the .ir file
					System.setOut(outputStream);
				}
				catch (FileNotFoundException e) {
					e.printStackTrace();
				}
				// Begin traversal
				IrCodeGenerator irGen = new IrCodeGenerator();
				root.jjtAccept(irGen, null);

			} catch (ParseException e) {
				System.err.println(e);
			}
		}
	}

PARSER_END(AssignmentTwo)

TOKEN_MGR_DECLS :
{
	static int commentNesting = 0;
}

// Tokens for the parser to skip
SKIP: 
{
	< " " | "\t" | "\n" | "\r" | "\r\n" >
	| < "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
}

SKIP : /* COMMENTS */
{
	"/*" { commentNesting++; } : IN_COMMENT
}

<IN_COMMENT> SKIP :
{
	"/*" { commentNesting++; }
  | "*/" { commentNesting--;
	if (commentNesting == 0)
		SwitchTo(DEFAULT);
	}
  | <~[]>
}

// Static Tokens
TOKEN:
{
	<COMMA: ",">
	| <SEMICOLON: ";">
	| <COLON: ":">
	| <ASSIGNMENT: ":=">
	| <LBRACE: "(">
	| <RBRACE: ")">
	| <PLUS: "+">
	| <MINUS: "-">
	| <NOT: "~">
	| <OR: "|" >
	| <AND: "&">
	| <EQUALS: "=">
	| <NOT_EQUALS: "!=">
	| <LESS_THAN: "<">
	| <LESS_THAN_OR_EQUAL: "<=">
	| <GREATER_THAN: ">">
	| <GREATER_THAN_OR_EQUAL: ">=">
}

// Reserved Tokens
TOKEN:
{	
	<VARIABLE: "variable">
	| <CONSTANT: "constant">
	| <RETURN: "return">
	| <INTEGER: "integer">
	| <BOOLEAN: "boolean">
	| <VOID: "void">
	| <MAIN: "main">
	| <IF: "if">
	| <ELSE: "else">
	| <TRUE: "true">
	| <FALSE: "false">
	| <WHILE: "while">
	| <BEGIN: "begin">
	| <END: "end">
	| <IS: "is">
	| <SKIP_TOKEN: "skip">
}

// Identifier Tokens                                                               
TOKEN:                                                                             
{                                                                                  
    <DIGIT: (<MINUS>)? "0" | ((<MINUS>)? ["1" - "9"] (["0" - "9"])*) >
    | <ID: <LETTER>(<LETTER>|<DIGIT>|<UNDERSCORE>)* >                              
    | <# LETTER: (["a"-"z", "A"-"Z"])+ >
    | <# UNDERSCORE: "_" >                                                         
} 

// Start production rule.
// 0 or 1 declaration lists, followed by
// 0 or 1 function lists, followed by
// our main function.
SimpleNode program()         : {/*@bgen(jjtree) Program */
  ASTProgram jjtn000 = new ASTProgram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Program */
 try {
/*@egen*/	
	// Declarations
	[DeclarationList()]

	// Functions
	[FunctionList()]

	// Main Program
	Main()
	<EOF>/*@bgen(jjtree)*/
 {
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
 }
/*@egen*/

	{return jjtn000;}/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

/* Declaration Rules */
// A declaration list has one or more declarations.
void DeclarationList(): 
{}
{
	(Declaration() <SEMICOLON>)+
}

/* A declaration is comprised of either:
 * 1) A Variable declaration
 * 2) A Constant declaration
 */
void Declaration():
{}
{
	VariableDeclaration() 
	| ConstantDeclaration()
}

// Variable structure construct
void VariableDeclaration()         : {/*@bgen(jjtree) VarDecl */
                                      ASTVarDecl jjtn000 = new ASTVarDecl(JJTVARDECL);
                                      boolean jjtc000 = true;
                                      jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String ID; String type;}
{/*@bgen(jjtree) VarDecl */
 try {
/*@egen*/
	t = <VARIABLE> ID = Identifier() <COLON> type = Type()/*@bgen(jjtree)*/
 {
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
 }
/*@egen*/
	{
		jjtn000.value = t.image;
		ST.put(ID, type, "var", scope);
	}/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

// Constant structure construct
void ConstantDeclaration()           :
{/*@bgen(jjtree) ConstDecl */
 ASTConstDecl jjtn000 = new ASTConstDecl(JJTCONSTDECL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String ID; String type;}
{/*@bgen(jjtree) ConstDecl */
 try {
/*@egen*/
	t = <CONSTANT> ID = Identifier() <COLON> type = Type() <ASSIGNMENT> expression()/*@bgen(jjtree)*/
 {
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
 }
/*@egen*/
	{
		jjtn000.value = t.image;
		ST.put(ID, type, "const", scope);
	}/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

/* Function Rules */
// A function_list has one or more functions
void FunctionList():
{}
{
	(/*@bgen(jjtree) Function */
  {
    ASTFunction jjtn001 = new ASTFunction(JJTFUNCTION);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/function()/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
  }
/*@egen*/          ) [FunctionList()]
}

// Function definition
// Takes a parameter list with 0 or more parameters.
// Takes 0 or 1 declaration lists.
// Within the function begin, we define a statement block 0 or 1 times.
// Return 0 or 1 expressions. 
void function():
{String type; String ID;}
{
	(type = Type() ID = Identifier() 
	{
		ST.put(ID, type, "function", scope);
		if(!scope.equals("global")) {
			// Add function name to the global score LinkedList.
        	ST.put(ID, type, "function", "global");
        }
		// Set new scope here for function.
     	scope = ID;
	}
	<LBRACE> parameter_list() <RBRACE> <IS>
	[DeclarationList()]
	<BEGIN>
		statement_block()/*@bgen(jjtree) FuncReturn */
     {
       ASTFuncReturn jjtn001 = new ASTFuncReturn(JJTFUNCRETURN);
       boolean jjtc001 = true;
       jjtree.openNodeScope(jjtn001);
     }
     try {
/*@egen*/
	    function_return()/*@bgen(jjtree)*/
     } catch (Throwable jjte001) {
       if (jjtc001) {
         jjtree.clearNodeScope(jjtn001);
         jjtc001 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte001 instanceof RuntimeException) {
         throw (RuntimeException)jjte001;
       }
       if (jjte001 instanceof ParseException) {
         throw (ParseException)jjte001;
       }
       throw (Error)jjte001;
     } finally {
       if (jjtc001) {
         jjtree.closeNodeScope(jjtn001, true);
       }
     }
/*@egen*/            
	<END>)
	{scope = "global";}
}

void function_return() : {Token t;}
{
    <RETURN> (<LBRACE> [expression()] <RBRACE>) <SEMICOLON> 
}

// Defines parameter list.
// Either is a non-empty parameter list or an empty one (0 or 1)
void parameter_list()                :
{/*@bgen(jjtree) Parameter_list */
  ASTParameter_list jjtn000 = new ASTParameter_list(JJTPARAMETER_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Parameter_list */
 try {
/*@egen*/
	[/*@bgen(jjtree) Parameter */
  {
    ASTParameter jjtn001 = new ASTParameter(JJTPARAMETER);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/nemp_parameter_list()/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
  }
/*@egen*/           ]/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

// Non-empty parameter list structure.
void nemp_parameter_list():
{String ID; String type;}
{
	ID = Identifier() <COLON> type = Type() [<COMMA>/*@bgen(jjtree) Parameter */
                                                  {
                                                    ASTParameter jjtn001 = new ASTParameter(JJTPARAMETER);
                                                    boolean jjtc001 = true;
                                                    jjtree.openNodeScope(jjtn001);
                                                  }
                                                  try {
/*@egen*/ nemp_parameter_list()/*@bgen(jjtree)*/
                                                  } catch (Throwable jjte001) {
                                                    if (jjtc001) {
                                                      jjtree.clearNodeScope(jjtn001);
                                                      jjtc001 = false;
                                                    } else {
                                                      jjtree.popNode();
                                                    }
                                                    if (jjte001 instanceof RuntimeException) {
                                                      throw (RuntimeException)jjte001;
                                                    }
                                                    if (jjte001 instanceof ParseException) {
                                                      throw (ParseException)jjte001;
                                                    }
                                                    throw (Error)jjte001;
                                                  } finally {
                                                    if (jjtc001) {
                                                      jjtree.closeNodeScope(jjtn001, true);
                                                    }
                                                  }
/*@egen*/           ]
	{ ST.put(ID, type, "parameter", scope); }
}

// A statement block is simply 0 or more statements.
void statement_block():
{}
{
	(statement())*
}

// Statement structure - has many possible routes.
// Skip token is used to skip the expection of anything else inside statement.
void statement()           :
{/*@bgen(jjtree) Statement */
 ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Statement */
 try {
/*@egen*/
	Identifier() (/*@bgen(jjtree) Assignment */
               {
                 ASTAssignment jjtn001 = new ASTAssignment(JJTASSIGNMENT);
                 boolean jjtc001 = true;
                 jjtree.openNodeScope(jjtn001);
               }
               try {
/*@egen*/<ASSIGNMENT>/*@bgen(jjtree)*/
               } finally {
                 if (jjtc001) {
                   jjtree.closeNodeScope(jjtn001, true);
                 }
               }
/*@egen*/             expression() <SEMICOLON> | <LBRACE> (/*@bgen(jjtree) Arg_list */
                                                                             {
                                                                               ASTArg_list jjtn002 = new ASTArg_list(JJTARG_LIST);
                                                                               boolean jjtc002 = true;
                                                                               jjtree.openNodeScope(jjtn002);
                                                                             }
                                                                             try {
/*@egen*/arg_list()/*@bgen(jjtree)*/
                                                                             } catch (Throwable jjte002) {
                                                                               if (jjtc002) {
                                                                                 jjtree.clearNodeScope(jjtn002);
                                                                                 jjtc002 = false;
                                                                               } else {
                                                                                 jjtree.popNode();
                                                                               }
                                                                               if (jjte002 instanceof RuntimeException) {
                                                                                 throw (RuntimeException)jjte002;
                                                                               }
                                                                               if (jjte002 instanceof ParseException) {
                                                                                 throw (ParseException)jjte002;
                                                                               }
                                                                               throw (Error)jjte002;
                                                                             } finally {
                                                                               if (jjtc002) {
                                                                                 jjtree.closeNodeScope(jjtn002, true);
                                                                               }
                                                                             }
/*@egen*/          ) <RBRACE> <SEMICOLON>)
	| statement_begin_structure()
	|  (t = <IF> condition() statement_begin_structure()/*@bgen(jjtree)*/
                                                      {
                                                        jjtree.closeNodeScope(jjtn000, true);
                                                        jjtc000 = false;
                                                      }
/*@egen*/ {jjtn000.value = t.image;})
	|  (t = <ELSE> statement_begin_structure()/*@bgen(jjtree)*/
                                            {
                                              jjtree.closeNodeScope(jjtn000, true);
                                              jjtc000 = false;
                                            }
/*@egen*/ {jjtn000.value = t.image;})
	|  (t = <WHILE> condition() statement_begin_structure()/*@bgen(jjtree)*/
                                                         {
                                                           jjtree.closeNodeScope(jjtn000, true);
                                                           jjtc000 = false;
                                                         }
/*@egen*/ {jjtn000.value = t.image;})
	| <SKIP_TOKEN> <SEMICOLON>/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

// Fragment definition - tied to expression definition.
// An expression can evaluate to our list of primitive tokens - 
// Minus Digit, Minus ID, Digit, True, False.
void fragment():
{Token t;}
{
    (<MINUS>/*@bgen(jjtree) Minus_sign */
             {
               ASTMinus_sign jjtn001 = new ASTMinus_sign(JJTMINUS_SIGN);
               boolean jjtc001 = true;
               jjtree.openNodeScope(jjtn001);
             }
             try {
/*@egen*/ Identifier()/*@bgen(jjtree)*/
             } catch (Throwable jjte001) {
               if (jjtc001) {
                 jjtree.clearNodeScope(jjtn001);
                 jjtc001 = false;
               } else {
                 jjtree.popNode();
               }
               if (jjte001 instanceof RuntimeException) {
                 throw (RuntimeException)jjte001;
               }
               if (jjte001 instanceof ParseException) {
                 throw (ParseException)jjte001;
               }
               throw (Error)jjte001;
             } finally {
               if (jjtc001) {
                 jjtree.closeNodeScope(jjtn001, true);
               }
             }
/*@egen*/            )
	| t = <TRUE>/*@bgen(jjtree) Boolean */
              {
                ASTBoolean jjtn002 = new ASTBoolean(JJTBOOLEAN);
                boolean jjtc002 = true;
                jjtree.openNodeScope(jjtn002);
              }
              try {
/*@egen*//*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn002, true);
                jjtc002 = false;
              }
/*@egen*/ {jjtn002.value = t.image;}/*@bgen(jjtree)*/
              } finally {
                if (jjtc002) {
                  jjtree.closeNodeScope(jjtn002, true);
                }
              }
/*@egen*/         
	| t = <FALSE>/*@bgen(jjtree) Boolean */
               {
                 ASTBoolean jjtn003 = new ASTBoolean(JJTBOOLEAN);
                 boolean jjtc003 = true;
                 jjtree.openNodeScope(jjtn003);
               }
               try {
/*@egen*//*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn003, true);
                 jjtc003 = false;
               }
/*@egen*/ {jjtn003.value = t.image;}/*@bgen(jjtree)*/
               } finally {
                 if (jjtc003) {
                   jjtree.closeNodeScope(jjtn003, true);
                 }
               }
/*@egen*/         
    | Number() 
}

/* Expression can be a simple_expression() followed by 0 or 1 more
 * Arithmetic operators and an expression.
 */
void expression():
{Token t;}
{
    simple_expression() 
	[
		t = <PLUS> expression()/*@bgen(jjtree) #Add_Op( 2) */
                            {
                              ASTAdd_Op jjtn001 = new ASTAdd_Op(JJTADD_OP);
                              boolean jjtc001 = true;
                              jjtree.openNodeScope(jjtn001);
                            }
                            try {
/*@egen*//*@bgen(jjtree)*/
                            {
                              jjtree.closeNodeScope(jjtn001,  2);
                              jjtc001 = false;
                            }
/*@egen*/   {jjtn001.value = t.image;}/*@bgen(jjtree)*/
                            } finally {
                              if (jjtc001) {
                                jjtree.closeNodeScope(jjtn001,  2);
                              }
                            }
/*@egen*/           
	| 	t = <MINUS> expression()/*@bgen(jjtree) #Add_Op( 2) */
                              {
                                ASTAdd_Op jjtn002 = new ASTAdd_Op(JJTADD_OP);
                                boolean jjtc002 = true;
                                jjtree.openNodeScope(jjtn002);
                              }
                              try {
/*@egen*//*@bgen(jjtree)*/
                              {
                                jjtree.closeNodeScope(jjtn002,  2);
                                jjtc002 = false;
                              }
/*@egen*/  {jjtn002.value = t.image;}/*@bgen(jjtree)*/
                              } finally {
                                if (jjtc002) {
                                  jjtree.closeNodeScope(jjtn002,  2);
                                }
                              }
/*@egen*/           
	]
}

/* A simple expression defines either:
 * 1) A fragment as previously defined.
 * 2) An expression with a Left parenthese and Right parenthese surrounding.
 * 3) An ID followed by 0 or 1 Left parenthese + argument list + right parenthese.
 */
void simple_expression():
{}
{
    <LBRACE> expression() <RBRACE>
    | Identifier() [<LBRACE> (/*@bgen(jjtree) Arg_list */
                              {
                                ASTArg_list jjtn001 = new ASTArg_list(JJTARG_LIST);
                                boolean jjtc001 = true;
                                jjtree.openNodeScope(jjtn001);
                              }
                              try {
/*@egen*/arg_list()/*@bgen(jjtree)*/
                              } catch (Throwable jjte001) {
                                if (jjtc001) {
                                  jjtree.clearNodeScope(jjtn001);
                                  jjtc001 = false;
                                } else {
                                  jjtree.popNode();
                                }
                                if (jjte001 instanceof RuntimeException) {
                                  throw (RuntimeException)jjte001;
                                }
                                if (jjte001 instanceof ParseException) {
                                  throw (ParseException)jjte001;
                                }
                                throw (Error)jjte001;
                              } finally {
                                if (jjtc001) {
                                  jjtree.closeNodeScope(jjtn001, true);
                                }
                              }
/*@egen*/          ) <RBRACE>]
    | fragment()
}

// A condition firstly can be instantiated with either a not token (~ tilde) or not.
// Following is a simple condition with 0 or 1 logical operators followed by a condition.
// Structure is very similar to expression() above but with the NOT token.
void condition():
{Token t;}
{   
   	(<NOT> simple_condition() | simple_condition())
	[  t = <AND> condition()/*@bgen(jjtree) #LogicalAND( 2) */
                          {
                            ASTLogicalAND jjtn001 = new ASTLogicalAND(JJTLOGICALAND);
                            boolean jjtc001 = true;
                            jjtree.openNodeScope(jjtn001);
                          }
                          try {
/*@egen*//*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn001,  2);
                            jjtc001 = false;
                          }
/*@egen*/ {jjtn001.value = t.image;}/*@bgen(jjtree)*/
                          } finally {
                            if (jjtc001) {
                              jjtree.closeNodeScope(jjtn001,  2);
                            }
                          }
/*@egen*/               
	|  t = <OR> condition()/*@bgen(jjtree) #LogicalOR( 2) */
                         {
                           ASTLogicalOR jjtn002 = new ASTLogicalOR(JJTLOGICALOR);
                           boolean jjtc002 = true;
                           jjtree.openNodeScope(jjtn002);
                         }
                         try {
/*@egen*//*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn002,  2);
                           jjtc002 = false;
                         }
/*@egen*/ {jjtn002.value = t.image;}/*@bgen(jjtree)*/
                         } finally {
                           if (jjtc002) {
                             jjtree.closeNodeScope(jjtn002,  2);
                           }
                         }
/*@egen*/              
	]
}

/* A simple condition takes a left bracket, condition, right bracket or
 * It takes a special_expression followed by 0 or 1 comparison operators and another
 * expression.
 * The special_expression is necessary for allowing the parser to have no difficulty,
 * when deciding what choice to make in our parser.
*/
void simple_condition():
{Token t;}
{   
    (<LBRACE> condition() <RBRACE> 
	| special_expression())
	[	t = <EQUALS>  expression()/*@bgen(jjtree) #Equals( 2) */
                              {
                                ASTEquals jjtn001 = new ASTEquals(JJTEQUALS);
                                boolean jjtc001 = true;
                                jjtree.openNodeScope(jjtn001);
                              }
                              try {
/*@egen*//*@bgen(jjtree)*/
                              {
                                jjtree.closeNodeScope(jjtn001,  2);
                                jjtc001 = false;
                              }
/*@egen*/ {jjtn001.value = t.image;}/*@bgen(jjtree)*/
                              } finally {
                                if (jjtc001) {
                                  jjtree.closeNodeScope(jjtn001,  2);
                                }
                              }
/*@egen*/           
	| 	t = <NOT_EQUALS>  expression()/*@bgen(jjtree) #Not_Equals( 2) */
                                   {
                                     ASTNot_Equals jjtn002 = new ASTNot_Equals(JJTNOT_EQUALS);
                                     boolean jjtc002 = true;
                                     jjtree.openNodeScope(jjtn002);
                                   }
                                   try {
/*@egen*//*@bgen(jjtree)*/
                                   {
                                     jjtree.closeNodeScope(jjtn002,  2);
                                     jjtc002 = false;
                                   }
/*@egen*/ {jjtn002.value = t.image;}/*@bgen(jjtree)*/
                                   } finally {
                                     if (jjtc002) {
                                       jjtree.closeNodeScope(jjtn002,  2);
                                     }
                                   }
/*@egen*/               
	| 	t = <LESS_THAN>  expression()/*@bgen(jjtree) #Less_Than( 2) */
                                  {
                                    ASTLess_Than jjtn003 = new ASTLess_Than(JJTLESS_THAN);
                                    boolean jjtc003 = true;
                                    jjtree.openNodeScope(jjtn003);
                                  }
                                  try {
/*@egen*//*@bgen(jjtree)*/
                                  {
                                    jjtree.closeNodeScope(jjtn003,  2);
                                    jjtc003 = false;
                                  }
/*@egen*/ {jjtn003.value = t.image;}/*@bgen(jjtree)*/
                                  } finally {
                                    if (jjtc003) {
                                      jjtree.closeNodeScope(jjtn003,  2);
                                    }
                                  }
/*@egen*/              
	| 	t = <LESS_THAN_OR_EQUAL>  expression()/*@bgen(jjtree) #Less_Than_Or_Equal( 2) */
                                           {
                                             ASTLess_Than_Or_Equal jjtn004 = new ASTLess_Than_Or_Equal(JJTLESS_THAN_OR_EQUAL);
                                             boolean jjtc004 = true;
                                             jjtree.openNodeScope(jjtn004);
                                           }
                                           try {
/*@egen*//*@bgen(jjtree)*/
                                           {
                                             jjtree.closeNodeScope(jjtn004,  2);
                                             jjtc004 = false;
                                           }
/*@egen*/ {jjtn004.value = t.image;}/*@bgen(jjtree)*/
                                           } finally {
                                             if (jjtc004) {
                                               jjtree.closeNodeScope(jjtn004,  2);
                                             }
                                           }
/*@egen*/                       
	| 	t = <GREATER_THAN>  expression()/*@bgen(jjtree) #Greater_Than( 2) */
                                     {
                                       ASTGreater_Than jjtn005 = new ASTGreater_Than(JJTGREATER_THAN);
                                       boolean jjtc005 = true;
                                       jjtree.openNodeScope(jjtn005);
                                     }
                                     try {
/*@egen*//*@bgen(jjtree)*/
                                     {
                                       jjtree.closeNodeScope(jjtn005,  2);
                                       jjtc005 = false;
                                     }
/*@egen*/ {jjtn005.value = t.image;}/*@bgen(jjtree)*/
                                     } finally {
                                       if (jjtc005) {
                                         jjtree.closeNodeScope(jjtn005,  2);
                                       }
                                     }
/*@egen*/                 
	| 	t = <GREATER_THAN_OR_EQUAL> expression()/*@bgen(jjtree) #Greater_Than_Or_Equal( 2) */
                                             {
                                               ASTGreater_Than_Or_Equal jjtn006 = new ASTGreater_Than_Or_Equal(JJTGREATER_THAN_OR_EQUAL);
                                               boolean jjtc006 = true;
                                               jjtree.openNodeScope(jjtn006);
                                             }
                                             try {
/*@egen*//*@bgen(jjtree)*/
                                             {
                                               jjtree.closeNodeScope(jjtn006,  2);
                                               jjtc006 = false;
                                             }
/*@egen*/ {jjtn006.value = t.image;}/*@bgen(jjtree)*/
                                             } finally {
                                               if (jjtc006) {
                                                 jjtree.closeNodeScope(jjtn006,  2);
                                               }
                                             }
/*@egen*/                          
	] 
}

// Special Expression structure - similar to expression / condition.
void special_expression():
{Token t;}
{
    simple_special_expression() 
	[
		t = <PLUS> special_expression()/*@bgen(jjtree) #Add_Op( 2) */
                                    {
                                      ASTAdd_Op jjtn001 = new ASTAdd_Op(JJTADD_OP);
                                      boolean jjtc001 = true;
                                      jjtree.openNodeScope(jjtn001);
                                    }
                                    try {
/*@egen*//*@bgen(jjtree)*/
                                    {
                                      jjtree.closeNodeScope(jjtn001,  2);
                                      jjtc001 = false;
                                    }
/*@egen*/   {jjtn001.value = t.image;}/*@bgen(jjtree)*/
                                    } finally {
                                      if (jjtc001) {
                                        jjtree.closeNodeScope(jjtn001,  2);
                                      }
                                    }
/*@egen*/           
	| 	t = <MINUS> special_expression()/*@bgen(jjtree) #Add_Op( 2) */
                                      {
                                        ASTAdd_Op jjtn002 = new ASTAdd_Op(JJTADD_OP);
                                        boolean jjtc002 = true;
                                        jjtree.openNodeScope(jjtn002);
                                      }
                                      try {
/*@egen*//*@bgen(jjtree)*/
                                      {
                                        jjtree.closeNodeScope(jjtn002,  2);
                                        jjtc002 = false;
                                      }
/*@egen*/  {jjtn002.value = t.image;}/*@bgen(jjtree)*/
                                      } finally {
                                        if (jjtc002) {
                                          jjtree.closeNodeScope(jjtn002,  2);
                                        }
                                      }
/*@egen*/           
	]
}

// Similar to simple_expression, but without the <LBRACE> choice conflict.
void simple_special_expression():
{}
{
    Identifier() [<LBRACE> (/*@bgen(jjtree) Arg_list */
                            {
                              ASTArg_list jjtn001 = new ASTArg_list(JJTARG_LIST);
                              boolean jjtc001 = true;
                              jjtree.openNodeScope(jjtn001);
                            }
                            try {
/*@egen*/arg_list()/*@bgen(jjtree)*/
                            } catch (Throwable jjte001) {
                              if (jjtc001) {
                                jjtree.clearNodeScope(jjtn001);
                                jjtc001 = false;
                              } else {
                                jjtree.popNode();
                              }
                              if (jjte001 instanceof RuntimeException) {
                                throw (RuntimeException)jjte001;
                              }
                              if (jjte001 instanceof ParseException) {
                                throw (ParseException)jjte001;
                              }
                              throw (Error)jjte001;
                            } finally {
                              if (jjtc001) {
                                jjtree.closeNodeScope(jjtn001, true);
                              }
                            }
/*@egen*/          ) <RBRACE>]
    | fragment()
}

// Argument list is 0 or 1 non-empty argument lists.
// Non-empty argument list, is a list of IDs with COMMAs separating them.
void arg_list():
{}
{
    [nemp_arg_list()]
}

void nemp_arg_list():
{}
{
    Identifier() [<COMMA> arg_list()]
}

// Structure to statements
void statement_begin_structure():
{}
{
	<BEGIN>
		statement_block()
	<END>
}

void Number()        : 
{/*@bgen(jjtree) Number */
 ASTNumber jjtn000 = new ASTNumber(JJTNUMBER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Number */
 try {
/*@egen*/
	t = <DIGIT>/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ {jjtn000.value = t.image;}/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

String Identifier()            :
{/*@bgen(jjtree) Identifier */
 ASTIdentifier jjtn000 = new ASTIdentifier(JJTIDENTIFIER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Identifier */
  try {
/*@egen*/
  t = <ID>/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ {jjtn000.value = t.image; return t.image;}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// Defines the type for AST matching cases.
String Type()      :
{/*@bgen(jjtree) Type */
 ASTType jjtn000 = new ASTType(JJTTYPE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Type */
 try {
/*@egen*/
	t = <VOID>/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/  {jjtn000.value = t.image; return t.image;}
  | t = <INTEGER>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/  {jjtn000.value = t.image; return t.image;}
  | t = <BOOLEAN>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ {jjtn000.value = t.image; return t.image;}/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

// Our main function definition.
void Main()      :
{/*@bgen(jjtree) Main */
  ASTMain jjtn000 = new ASTMain(JJTMAIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Main */
 try {
/*@egen*/
	{scope = "main";}
	(
		<MAIN>
			<BEGIN> 
				[DeclarationList()] 
				(statement_block()) 
			<END>
	)/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}