/* Shane Creedon 
 * Student ID: 15337356
 * Module: CA4003 Compiler Construction Assignment 1
 * @David Sinclair: Please use this version of my code as my final edition.
 */

// Options for Lexer and Parser
options {
	STATIC = false;
	IGNORE_CASE = true;
	MULTI=true;
	VISITOR=true;
}

// Define Parser Scope
PARSER_BEGIN(AssignmentTwo)

	import java.io.*;
	import java.util.*;
	
	// Main class for passing in CAL code.
	class AssignmentTwo {

		public static Hashtable ST = new Hashtable();
		
		public static void main(String[] args) throws ParseException, TokenMgrError, FileNotFoundException {
			
			String temp;
			STC temp2;
			
			if(args.length < 1) {		
				System.out.println("Please pass in the filename.");
				System.exit(1);
			}
		
			// parser initialisation
			AssignmentTwo parser = new AssignmentTwo(new FileInputStream(args[0]));

			SimpleNode root = parser.program();
			System.out.println("Abstract Syntax Tree:");
			root.dump(" ");

			System.out.println();
			System.out.println("Symbol Table:");

			Enumeration t = ST.keys();

			while (t.hasMoreElements())
			{
			  temp = (String)t.nextElement();
			  temp2 = (STC)ST.get(temp);
			  System.out.println(temp);
			  if (temp2.type != null)
			  {
				System.out.println(" type = " + temp2.type);
			  }
			  if (temp2.value != null)
			  {
				System.out.println(" value = " + temp2.value);
			  }
			}

			System.out.println();
			System.out.println("Program:");
			PrintVisitor pv = new PrintVisitor();
			root.jjtAccept(pv, null);

			System.out.println();
			System.out.println("Type Checking:");
			TypeCheckVisitor tc = new TypeCheckVisitor();
			root.jjtAccept(tc, ST);  			

		}
	}

PARSER_END(AssignmentTwo)

// Tokens for the parser to skip
SKIP: 
{
	< " " | "\t" | "\n" | "\r" | "\r\n" >
	| < "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
	| < "/*" (~[])* "*""/" >
}

// Static Tokens
TOKEN:
{
	<COMMA: ",">
	| <SEMICOLON: ";">
	| <COLON: ":">
	| <ASSIGNMENT: ":=">
	| <LBRACE: "(">
	| <RBRACE: ")">
	| <PLUS: "+">
	| <MINUS: "-">
	| <MULT: "*">
	| <DIVIDE: "/">
	| <NOT: "~">
	| <OR: "|" >
	| <AND: "&">
	| <EQUALS: "=">
	| <NOT_EQUALS: "!=">
	| <LESS_THAN: "<">
	| <LESS_THAN_OR_EQUAL: "<=">
	| <GREATER_THAN: ">">
	| <GREATER_THAN_OR_EQUAL: ">=">
}

// Reserved Tokens
TOKEN:
{	
	<VARIABLE: "variable">
	| <CONSTANT: "constant">
	| <RETURN: "return">
	| <INTEGER: "integer">
	| <BOOLEAN: "boolean">
	| <VOID: "void">
	| <MAIN: "main">
	| <IF: "if">
	| <ELSE: "else">
	| <TRUE: "true">
	| <FALSE: "false">
	| <WHILE: "while">
	| <BEGIN: "begin">
	| <END: "end">
	| <IS: "is">
	| <SKIP_TOKEN: "skip">
}

// Identifier Tokens                                                               
TOKEN:                                                                             
{                                                                                  
    <DIGIT: "0" | (["1" - "9"]) (["0" - "9"])* >
    | <ID: <LETTER>(<LETTER>|<DIGIT>|<UNDERSCORE>)* >                              
    | <# LETTER: (["a"-"z", "A"-"Z"])+ >
    | <# UNDERSCORE: "_" >                                                         
} 

// Start production rule.
// 0 or 1 declaration lists, followed by
// 0 or 1 function lists, followed by
// our main function.
SimpleNode program():
{}
{	
	// Declarations
	[dec_list()]

	// Functions
	[function_list() #Function_list]

	// Main Program
	main()
	<EOF>

	{return jjtThis;}
}

/* Declaration Rules */
// A declaration list has one or more declarations.
void dec_list() #Dec_list:
{}
{
	(decl() #Decl)+
}

/* A declaration is comprised of either:
 * 1) A Variable declaration
 * 2) A Constant declaration
 */
void decl() #void:
{}
{
	var_decl() 
	| const_decl()
}

// Variable structure construct
void var_decl() #void:
{Token t; String name;}
{
	<VARIABLE> name = identifier() <COLON>
	(
		typeInteger() <SEMICOLON> 
		{ST.put(name, new STC("Integer", name));} #Var_decl(2)
    |
		typeBoolean() <SEMICOLON>
		{ST.put(name, new STC("Boolean", name));} #Var_decl(2)
	)
}

// Constant structure construct
void const_decl() #void:
{Token t; String name;}
{
	<CONSTANT> name = identifier() <COLON> 
	(
		typeInteger() assignmentExpression()
		{ST.put(name, new STC("Integer", name));} #Const_decl(3)
    |
		typeBoolean() assignmentExpression()
		{ST.put(name, new STC("Boolean", name));} #Const_decl(3)
	)
}

/* Function Rules */
// A function_list has one or more functions
void function_list() #void:
{}
{
	(function() #Function) [function_list()]
}

// Function definition
// Takes a parameter list with 0 or more parameters.
// Takes 0 or 1 declaration lists.
// Within the function begin, we define a statement block 0 or 1 times.
// Return 0 or 1 expressions. 
void function() #void:
{}
{
	anyType() identifier() <LBRACE> parameter_list() <RBRACE> <IS>
	[dec_list()]
	<BEGIN>
		(statement_block() #Statement_block)
		function_return()
	<END>
}

void function_return() #void:
{}
{
	((<RETURN> <LBRACE> [expression()] <RBRACE> <SEMICOLON>) #Return)
}


// Defines parameter list.
// Either is a non-empty parameter list or an empty one (0 or 1)
void parameter_list() #Parameter_list:
{}
{
	[nemp_parameter_list() #Nemp_parameter_list]
}

// Non-empty parameter list structure.
void nemp_parameter_list() #void:
{}
{
	identifier() <COLON> anyType() [<COMMA> nemp_parameter_list() #Nemp_parameter_list]
}

// A statement block is simply 0 or more statements.
void statement_block() #void:
{}
{
	(statement())*
}

// Statement structure - has many possible routes.
// Skip token is used to skip the expection of anything else inside statement.
void statement() #Statement:
{}
{
	identifier() (assignmentExpression() | functionCallStatement())
	| <BEGIN>
	      statement_block() 
	  <END>
	| <IF> condition()
	      <BEGIN>
	          statement_block()
	      <END>
	| <ELSE>
	      <BEGIN>
		      statement_block()
		  <END>
	| <WHILE> condition()
		  <BEGIN>
		      statement_block()
		  <END>
	| <SKIP_TOKEN> <SEMICOLON>
}

// Fragment definition - tied to expression definition.
// An expression can evaluate to our list of primitive tokens - 
// Minus Digit, Minus ID, Digit, True, False.
void fragment() #void:
{Token t;}
{
    ((t = <MINUS>) (number() | identifier()) {jjtThis.value = t.image;} #Minus_sign(1))
    | number() | <TRUE> | <FALSE>
}

/* Expression can be a simple_expression() followed by 0 or 1 more
 * Arithmetic operators and an expression.
 */
void expression() #void:
{Token t;}
{
    simple_expression() 
	[
		((t = <PLUS> | t = <MINUS> | t = <MULT> | t = <DIVIDE>) expression() 
		{jjtThis.value = t.image;} #Binary_arith_op(2))
	]
}

/* A simple expression defines either:
 * 1) A fragment as previously defined.
 * 2) An expression with a Left parenthese and Right parenthese surrounding.
 * 3) An ID followed by 0 or 1 Left parenthese + argument list + right parenthese.
 */
void simple_expression() #Exp:
{}
{
    <LBRACE> expression() <RBRACE>
    | identifier() [<LBRACE> arg_list() <RBRACE>]
    | fragment()
}

// A condition firstly can be instantiated with either a not token (~ tilde) or not.
// Following is a simple condition with 0 or 1 logical operators followed by a condition.
// Structure is very similar to expression() above but with the NOT token.
void condition() #void:
{Token t;}
{   
    [<NOT> #Not_op] simple_condition() 
	[
		((t = <AND> | t = <OR>) condition()
		{jjtThis.value = t.image;} #Binary_logical_op)
	]
}

/* A simple condition takes a left bracket, condition, right bracket or
 * It takes a special_expression followed by 0 or 1 comparison operators and another
 * expression.
 * The special_expression is necessary for allowing the parser to have no difficulty,
 * when deciding what choice to make in our parser.
*/
void simple_condition() #Condition:
{Token t;}
{   
    <LBRACE> condition() <RBRACE>
    | special_expression() ((t = <EQUALS> 
	| t = <NOT_EQUALS> | t = <LESS_THAN> 
	| t = <LESS_THAN_OR_EQUAL> | t = <GREATER_THAN> 
	| t = <GREATER_THAN_OR_EQUAL>) expression() 
	{jjtThis.value = t.image;} #Comparison_op(2))
}

// Special Expression structure - similar to expression / condition.
void special_expression() #void:
{Token t;}
{
    simple_special_expression() 
	[
		((t = <PLUS> | t = <MINUS> | t = <MULT> | t = <DIVIDE>) special_expression() 
		{jjtThis.value = t.image;} #Binary_arith_op(2))
	]
}

// Similar to simple_expression, but without the <LBRACE> choice conflict.
void simple_special_expression() #Exp:
{}
{
    identifier() [<LBRACE> arg_list() <RBRACE>]
    | fragment()
}

// Argument list is 0 or 1 non-empty argument lists.
void arg_list() #Arg_list:
{}
{
    [nemp_arg_list() #Nemp_arg_list]
}

// Non-empty argument list, is a list of IDs with COMMAs separating them.
void nemp_arg_list() #void:
{}
{
    identifier() [<COMMA> nemp_arg_list()]
}

void assignmentExpression() #Assignment_exp:
{}
{
  <ASSIGNMENT> expression() <SEMICOLON>
}

void functionCallStatement() #Function_call_statement:
{}
{
  <LBRACE> arg_list() <RBRACE> <SEMICOLON>
}

void number(): 
{Token t;}
{
	t = <DIGIT> {jjtThis.value = t.image;}
}

String identifier(): 
{Token t;}
{
	t = <ID> {jjtThis.value = t.image; return t.image;}
}

// Defines the type for AST matching.
void anyType():
{Token t;}
{
	(t = <VOID> | t = <INTEGER> | t = <BOOLEAN>) {jjtThis.value = t.image;}
}

void typeInteger():
{Token t;}
{
	t = <INTEGER> {jjtThis.value = t.image;}
}

void typeBoolean():
{Token t;}
{
	t = <BOOLEAN> {jjtThis.value = t.image;}
}

// Our main function definition.
void main() #Main:
{}
{
	<MAIN>
		<BEGIN> 
			[dec_list()] 
			(statement_block() #Statement_block) 
		<END>
}
