/* Shane Creedon 
 * Student ID: 15337356
 * Module: CA4003 Compiler Construction Assignment 2
 * @David Sinclair: Please use this version of my code as my final edition.
 */

// Options for Lexer and Parser
options {
	JAVA_UNICODE_ESCAPE = true;
	IGNORE_CASE = true;

	MULTI=true;
	VISITOR=true;
	NODE_DEFAULT_VOID = true;
}

// Define Parser Scope
PARSER_BEGIN(AssignmentTwo)

	import java.io.*;
	import java.util.*;
	
	// Main class for passing in CAL code.
	class AssignmentTwo {

		public static STC ST = new STC();
		public static String scope = "global";
		
		public static void main(String[] args) throws FileNotFoundException {
			
			if(args.length < 1) {		
				System.out.println("Please pass in the filename.");
				System.exit(1);
			}
			
			try {	
				// parser initialisation
				AssignmentTwo parser = new AssignmentTwo(new FileInputStream(args[0]));

				SimpleNode root = parser.program();
				System.out.println("Abstract Syntax Tree:");
				root.dump(" ");

				System.out.println();
				System.out.println("Symbol Table:");
				ST.print();

				/* System.out.println();
				System.out.println("Program:");
				PrintVisitor pv = new PrintVisitor();
				root.jjtAccept(pv, null); */

				System.out.println();
				System.out.println("Type Checking:");
				TypeCheckVisitor tc = new TypeCheckVisitor();
				root.jjtAccept(tc, ST);  			

			} catch (ParseException e) {
				System.err.println(e);
			}
		}
	}

PARSER_END(AssignmentTwo)

// Tokens for the parser to skip
SKIP: 
{
	< " " | "\t" | "\n" | "\r" | "\r\n" >
	| < "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
	| < "/*" (~[])* "*""/" >
}

// Static Tokens
TOKEN:
{
	<COMMA: ",">
	| <SEMICOLON: ";">
	| <COLON: ":">
	| <ASSIGNMENT: ":=">
	| <LBRACE: "(">
	| <RBRACE: ")">
	| <PLUS: "+">
	| <MINUS: "-">
	| <MULT: "*">
	| <DIVIDE: "/">
	| <NOT: "~">
	| <OR: "|" >
	| <AND: "&">
	| <EQUALS: "=">
	| <NOT_EQUALS: "!=">
	| <LESS_THAN: "<">
	| <LESS_THAN_OR_EQUAL: "<=">
	| <GREATER_THAN: ">">
	| <GREATER_THAN_OR_EQUAL: ">=">
}

// Reserved Tokens
TOKEN:
{	
	<VARIABLE: "variable">
	| <CONSTANT: "constant">
	| <RETURN: "return">
	| <INTEGER: "integer">
	| <BOOLEAN: "boolean">
	| <VOID: "void">
	| <MAIN: "main">
	| <IF: "if">
	| <ELSE: "else">
	| <TRUE: "true">
	| <FALSE: "false">
	| <WHILE: "while">
	| <BEGIN: "begin">
	| <END: "end">
	| <IS: "is">
	| <SKIP_TOKEN: "skip">
}

// Identifier Tokens                                                               
TOKEN:                                                                             
{                                                                                  
    <DIGIT: "0" | ((<MINUS>)? ["1" - "9"] (["0" - "9"])*) >
    | <ID: <LETTER>(<LETTER>|<DIGIT>|<UNDERSCORE>)* >                              
    | <# LETTER: (["a"-"z", "A"-"Z"])+ >
    | <# UNDERSCORE: "_" >                                                         
} 

// Start production rule.
// 0 or 1 declaration lists, followed by
// 0 or 1 function lists, followed by
// our main function.
SimpleNode program() #Program: {}
{	
	// Declarations
	[DeclarationList()]

	// Functions
	[FunctionList() #FunctionList]

	// Main Program
	Main()
	<EOF>

	{return jjtThis;}
}

/* Declaration Rules */
// A declaration list has one or more declarations.
void DeclarationList() #DeclarationList: 
{}
{
	(Declaration() <SEMICOLON>)+
}

/* A declaration is comprised of either:
 * 1) A Variable declaration
 * 2) A Constant declaration
 */
void Declaration():
{}
{
	VariableDeclaration() 
	| ConstantDeclaration()
}

// Variable structure construct
void VariableDeclaration() #VarDecl: {Token t; String id; String type;}
{
	t = <VARIABLE> id = Identifier() <COLON> type = Type()
	{
		jjtThis.value = t.image;
		ST.put(id, type, "var", scope);
	}
}

// Constant structure construct
void ConstantDeclaration() #ConstDecl:
{Token t; String id; String type;}
{
	t = <CONSTANT> id = Identifier() <COLON> type = Type() <ASSIGNMENT> expression()
	{
		jjtThis.value = t.image;
		ST.put(id, type, "const", scope);
	}
}

/* Function Rules */
// A function_list has one or more functions
void FunctionList():
{}
{
	(function() #Function) [FunctionList()]
}

// Function definition
// Takes a parameter list with 0 or more parameters.
// Takes 0 or 1 declaration lists.
// Within the function begin, we define a statement block 0 or 1 times.
// Return 0 or 1 expressions. 
void function():
{}
{
	Type() Identifier() <LBRACE> parameter_list() <RBRACE> <IS>
	[DeclarationList()]
	<BEGIN>
		(statement_block() #Statement_block)
		function_return()
	<END>
}

void function_return():
{}
{
	((<RETURN> <LBRACE> [expression()] <RBRACE> <SEMICOLON>) #Return)
}


// Defines parameter list.
// Either is a non-empty parameter list or an empty one (0 or 1)
void parameter_list() #Parameter_list:
{}
{
	[nemp_parameter_list() #Parameter]
}

// Non-empty parameter list structure.
void nemp_parameter_list():
{}
{
	Identifier() <COLON> Type() [<COMMA> nemp_parameter_list() #Parameter]
}

// A statement block is simply 0 or more statements.
void statement_block():
{}
{
	(statement())*
}

// Statement structure - has many possible routes.
// Skip token is used to skip the expection of anything else inside statement.
void statement() #Statement:
{Token t;}
{
	Identifier() (assignment_structure() | function_call_structure())
	| statement_begin_structure()
	| t = <IF> (condition() #Condition) statement_begin_structure()
	  {jjtThis.value = t.image;}
	| t = <ELSE> statement_begin_structure()
	  {jjtThis.value = t.image;}
	| t = <WHILE> (condition() #Condition) statement_begin_structure()
	  {jjtThis.value = t.image;}
	| <SKIP_TOKEN> <SEMICOLON>
}

// Fragment definition - tied to expression definition.
// An expression can evaluate to our list of primitive tokens - 
// Minus Digit, Minus ID, Digit, True, False.
void fragment():
{Token t;}
{
    ((t = <MINUS>) (Number() | Identifier()) {jjtThis.value = t.image;} #Minus_sign(1))
    | Number() | <TRUE> | <FALSE>
}

/* Expression can be a simple_expression() followed by 0 or 1 more
 * Arithmetic operators and an expression.
 */
void expression() #Exp:
{Token t;}
{
    simple_expression() 
	[
		t = <PLUS> expression()   {jjtThis.value = t.image;} #Add_Op(2)
	| 	t = <MINUS> expression()  {jjtThis.value = t.image;} #Minus_Op(2)
	| 	t = <MULT> expression()   {jjtThis.value = t.image;} #Mult_Op(2)
	| 	t = <DIVIDE> expression() {jjtThis.value = t.image;} #Div_Op(2)
	]
}

/* A simple expression defines either:
 * 1) A fragment as previously defined.
 * 2) An expression with a Left parenthese and Right parenthese surrounding.
 * 3) An ID followed by 0 or 1 Left parenthese + argument list + right parenthese.
 */
void simple_expression():
{}
{
    <LBRACE> (expression() #Bracket_Expression) <RBRACE>
    | Identifier() [<LBRACE> arg_list() <RBRACE>]
    | fragment()
}

// A condition firstly can be instantiated with either a not token (~ tilde) or not.
// Following is a simple condition with 0 or 1 logical operators followed by a condition.
// Structure is very similar to expression() above but with the NOT token.
void condition():
{Token t;}
{   
    ((<NOT> simple_condition() #Not_op(1))
	| simple_condition())
	[
		t = <AND> condition() {jjtThis.value = t.image;} #Logical_Conjunction(2)
	|   t = <OR> condition() {jjtThis.value = t.image;} #Logical_Disjunction(2)
	]
}

/* A simple condition takes a left bracket, condition, right bracket or
 * It takes a special_expression followed by 0 or 1 comparison operators and another
 * expression.
 * The special_expression is necessary for allowing the parser to have no difficulty,
 * when deciding what choice to make in our parser.
*/
void simple_condition():
{Token t;}
{   
    <LBRACE> (condition() #Bracket_Condition)<RBRACE>
    | special_expression() 
	(	t = <EQUALS>  expression() {jjtThis.value = t.image;} #Equals(2)
	| 	t = <NOT_EQUALS>  expression() {jjtThis.value = t.image;} #Not_Equals(2)
	| 	t = <LESS_THAN>  expression() {jjtThis.value = t.image;} #Less_Than(2)
	| 	t = <LESS_THAN_OR_EQUAL>  expression() {jjtThis.value = t.image;} #Less_Than_Or_Equal(2)
	| 	t = <GREATER_THAN>  expression() {jjtThis.value = t.image;} #Greater_Than(2)
	| 	t = <GREATER_THAN_OR_EQUAL> expression() {jjtThis.value = t.image;} #Greater_Than_Or_Equal(2)
	) 
}

// Special Expression structure - similar to expression / condition.
void special_expression():
{Token t;}
{
    simple_special_expression() 
	[
		t = <PLUS> special_expression()   {jjtThis.value = t.image;} #Add_Op(2)
	| 	t = <MINUS> special_expression()  {jjtThis.value = t.image;} #Minus_Op(2)
	| 	t = <MULT> special_expression()   {jjtThis.value = t.image;} #Mult_Op(2)
	| 	t = <DIVIDE> special_expression() {jjtThis.value = t.image;} #Div_Op(2)
	]
}

// Similar to simple_expression, but without the <LBRACE> choice conflict.
void simple_special_expression() #Exp:
{}
{
    Identifier() [<LBRACE> arg_list() <RBRACE>]
    | fragment()
}

// Argument list is 0 or 1 non-empty argument lists.
void arg_list() #Arg_list:
{}
{
    [nemp_arg_list() #Nemp_arg_list]
}

// Non-empty argument list, is a list of IDs with COMMAs separating them.
void nemp_arg_list():
{}
{
    Identifier() [<COMMA> nemp_arg_list()]
}

// Structure to assignments 
void assignment_structure() #Assignment_structure:
{}
{
  <ASSIGNMENT> expression() <SEMICOLON>
}

// Structure to function calls
void function_call_structure() #Function_call_structure:
{}
{
  <LBRACE> arg_list() <RBRACE> <SEMICOLON>
}

// Structure to statements
void statement_begin_structure() #Statement_Begin_Structure:
{}
{
	<BEGIN>
		statement_block()
	<END>
}

void Number() #Number: 
{Token t;}
{
	t = <DIGIT> {jjtThis.value = t.image;}
}

String Identifier() #Identifier:
{Token t;}
{
  t = <ID> {jjtThis.value = t.image; return t.image;}
}

// Defines the type for AST matching.
String Type() #Type:
{Token t;}
{
	t = <VOID>  {jjtThis.value = t.image; return t.image;}
  | t = <INTEGER>  {jjtThis.value = t.image; return t.image;}
  | t = <BOOLEAN> {jjtThis.value = t.image; return t.image;}
}

// Our main function definition.
void Main() #Main:
{}
{
	<MAIN>
		<BEGIN> 
			[DeclarationList()] 
			(statement_block() #Statement_block) 
		<END>
}
