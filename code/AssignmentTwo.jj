/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. AssignmentTwo.jj */
/*@egen*//* Shane Creedon 
 * Student ID: 15337356
 * Module: CA4003 Compiler Construction Assignment 1
 * @David Sinclair: Please use this version of my code as my final edition.
 */

// Options for Lexer and Parser
options {
	STATIC = false;
	IGNORE_CASE = true;
	           
	             
}

// Define Parser Scope
PARSER_BEGIN(AssignmentTwo)

	import java.io.*;
	import java.util.*;
	
	// Main class for passing in CAL code.
	class AssignmentTwo/*@bgen(jjtree)*/implements AssignmentTwoTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTAssignmentTwoState jjtree = new JJTAssignmentTwoState();

/*@egen*/

		public static Hashtable ST = new Hashtable();
		
		public static void main(String[] args) throws ParseException, TokenMgrError, FileNotFoundException {
			
			String temp;
			STC temp2;
			
			if(args.length < 1) {		
				System.out.println("Please pass in the filename.");
				System.exit(1);
			}
		
			// parser initialisation
			AssignmentTwo parser = new AssignmentTwo(new FileInputStream(args[0]));

			SimpleNode root = parser.program();
			System.out.println("Abstract Syntax Tree:");
			root.dump(" ");

			System.out.println();
			System.out.println("Symbol Table:");

			Enumeration t = ST.keys();

			while (t.hasMoreElements())
			{
			  temp = (String)t.nextElement();
			  temp2 = (STC)ST.get(temp);
			  System.out.println(temp);
			  if (temp2.type != null)
			  {
				System.out.println(" type = " + temp2.type);
			  }
			  if (temp2.value != null)
			  {
				System.out.println(" value = " + temp2.value);
			  }
			}

			System.out.println();
			System.out.println("Program:");
			PrintVisitor pv = new PrintVisitor();
			root.jjtAccept(pv, null);

			System.out.println();
			System.out.println("Type Checking:");
			TypeCheckVisitor tc = new TypeCheckVisitor();
			root.jjtAccept(tc, ST);  			

		}
	}

PARSER_END(AssignmentTwo)

// Tokens for the parser to skip
SKIP: 
{
	< " " | "\t" | "\n" | "\r" | "\r\n" >
	| < "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
	| < "/*" (~[])* "*""/" >
}

// Static Tokens
TOKEN:
{
	<COMMA: ",">
	| <SEMICOLON: ";">
	| <COLON: ":">
	| <ASSIGNMENT: ":=">
	| <LBRACE: "(">
	| <RBRACE: ")">
	| <PLUS: "+">
	| <MINUS: "-">
	| <MULT: "*">
	| <DIVIDE: "/">
	| <NOT: "~">
	| <BOOL_OP: "|" | "&">
	| <EQUALS: "=">
	| <NOT_EQUALS: "!=">
	| <LESS_THAN: "<">
	| <LESS_THAN_OR_EQUAL: "<=">
	| <GREATER_THAN: ">">
	| <GREATER_THAN_OR_EQUAL: ">=">
}

// Reserved Tokens
TOKEN:
{	
	<VARIABLE: "variable">
	| <CONSTANT: "constant">
	| <RETURN: "return">
	| <INTEGER: "integer">
	| <BOOLEAN: "boolean">
	| <VOID: "void">
	| <MAIN: "main">
	| <IF: "if">
	| <ELSE: "else">
	| <TRUE: "true">
	| <FALSE: "false">
	| <WHILE: "while">
	| <BEGIN: "begin">
	| <END: "end">
	| <IS: "is">
	| <SKIP_TOKEN: "skip">
}

// Identifier Tokens                                                               
TOKEN:                                                                             
{                                                                                  
    <DIGIT: "0" | (["1" - "9"]) (["0" - "9"])* >
    | <ID: <LETTER>(<LETTER>|<DIGIT>|<UNDERSCORE>)* >                              
    | <# LETTER: (["a"-"z", "A"-"Z"])+ >
    | <# UNDERSCORE: "_" >                                                         
} 

// Start production rule.
// 0 or 1 declaration lists, followed by
// 0 or 1 function lists, followed by
// our main function.
SimpleNode program():
{/*@bgen(jjtree) program */
  ASTprogram jjtn000 = new ASTprogram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) program */
 try {
/*@egen*/	
	// Declarations
	[dec_list()]

	// Functions
	[/*@bgen(jjtree) Function_list */
  {
    ASTFunction_list jjtn001 = new ASTFunction_list(JJTFUNCTION_LIST);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/function_list()/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
  }
/*@egen*/               ]

	// Main Program
	main()
	<EOF>/*@bgen(jjtree)*/
 {
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
 }
/*@egen*/

	{return jjtn000;}/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

/* Declaration Rules */
// A declaration list has one or more declarations.
void dec_list()          :
{/*@bgen(jjtree) Dec_list */
  ASTDec_list jjtn000 = new ASTDec_list(JJTDEC_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Dec_list */
 try {
/*@egen*/
	(/*@bgen(jjtree) Decl */
  {
    ASTDecl jjtn001 = new ASTDecl(JJTDECL);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/decl()/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
  }
/*@egen*/      )+/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

/* A declaration is comprised of either:
 * 1) A Variable declaration
 * 2) A Constant declaration
 */
void decl()      :
{}
{
	var_decl() 
	| const_decl()
}

// Variable structure construct
void var_decl()      :
{Token t; String name;}
{
	<VARIABLE> name = identifier() <COLON>
	(
		typeInteger() <SEMICOLON>/*@bgen(jjtree) #Var_decl( 2) */
  {
    ASTVar_decl jjtn001 = new ASTVar_decl(JJTVAR_DECL);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*//*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn001,  2);
    jjtc001 = false;
  }
/*@egen*/ 
		{ST.put(name, new STC("Integer", name));}/*@bgen(jjtree)*/
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  2);
    }
  }
/*@egen*/             
    |
		typeBoolean() <SEMICOLON>/*@bgen(jjtree) #Var_decl( 2) */
  {
    ASTVar_decl jjtn002 = new ASTVar_decl(JJTVAR_DECL);
    boolean jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
  }
  try {
/*@egen*//*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn002,  2);
    jjtc002 = false;
  }
/*@egen*/
		{ST.put(name, new STC("Boolean", name));}/*@bgen(jjtree)*/
  } finally {
    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002,  2);
    }
  }
/*@egen*/             
	)
}

// Constant structure construct
void const_decl()      :
{Token t; String name;}
{
	<CONSTANT> name = identifier() <COLON> 
	(
		typeInteger() assignmentExpression()/*@bgen(jjtree) #Const_decl( 3) */
  {
    ASTConst_decl jjtn001 = new ASTConst_decl(JJTCONST_DECL);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*//*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn001,  3);
    jjtc001 = false;
  }
/*@egen*/
		{ST.put(name, new STC("Integer", name));}/*@bgen(jjtree)*/
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  3);
    }
  }
/*@egen*/               
    |
		typeBoolean() assignmentExpression()/*@bgen(jjtree) #Const_decl( 3) */
  {
    ASTConst_decl jjtn002 = new ASTConst_decl(JJTCONST_DECL);
    boolean jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
  }
  try {
/*@egen*//*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn002,  3);
    jjtc002 = false;
  }
/*@egen*/
		{ST.put(name, new STC("Boolean", name));}/*@bgen(jjtree)*/
  } finally {
    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002,  3);
    }
  }
/*@egen*/               
	)
}

/* Function Rules */
// A function_list has one or more functions
void function_list()      :
{}
{
	(/*@bgen(jjtree) Function */
  {
    ASTFunction jjtn001 = new ASTFunction(JJTFUNCTION);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/function()/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
  }
/*@egen*/          ) [function_list()]
}

// Function definition
// Takes a parameter list with 0 or more parameters.
// Takes 0 or 1 declaration lists.
// Within the function begin, we define a statement block 0 or 1 times.
// Return 0 or 1 expressions. 
void function()      :
{}
{
	anyType() identifier() <LBRACE> parameter_list() <RBRACE> <IS>
	[dec_list()]
	<BEGIN>
		(/*@bgen(jjtree) Statement_block */
   {
     ASTStatement_block jjtn001 = new ASTStatement_block(JJTSTATEMENT_BLOCK);
     boolean jjtc001 = true;
     jjtree.openNodeScope(jjtn001);
   }
   try {
/*@egen*/statement_block()/*@bgen(jjtree)*/
   } catch (Throwable jjte001) {
     if (jjtc001) {
       jjtree.clearNodeScope(jjtn001);
       jjtc001 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte001 instanceof RuntimeException) {
       throw (RuntimeException)jjte001;
     }
     if (jjte001 instanceof ParseException) {
       throw (ParseException)jjte001;
     }
     throw (Error)jjte001;
   } finally {
     if (jjtc001) {
       jjtree.closeNodeScope(jjtn001, true);
     }
   }
/*@egen*/                 )
		function_return()
	<END>
}

void function_return()      :
{}
{
	(/*@bgen(jjtree) Return */
  {
    ASTReturn jjtn001 = new ASTReturn(JJTRETURN);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/(<RETURN> <LBRACE> [expression()] <RBRACE> <SEMICOLON>)/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
  }
/*@egen*/        )
}


// Defines parameter list.
// Either is a non-empty parameter list or an empty one (0 or 1)
void parameter_list()      :
{}
{
	[/*@bgen(jjtree) #Parameter_list( 2) */
  {
    ASTParameter_list jjtn001 = new ASTParameter_list(JJTPARAMETER_LIST);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/nemp_parameter_list()/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  2);
    }
  }
/*@egen*/                   ]
}

// Non-empty parameter list structure.
void nemp_parameter_list()      :
{}
{
	identifier() <COLON> anyType() [<COMMA>/*@bgen(jjtree) #Nemp_parameter_list( 2) */
                                         {
                                           ASTNemp_parameter_list jjtn001 = new ASTNemp_parameter_list(JJTNEMP_PARAMETER_LIST);
                                           boolean jjtc001 = true;
                                           jjtree.openNodeScope(jjtn001);
                                         }
                                         try {
/*@egen*/ nemp_parameter_list()/*@bgen(jjtree)*/
                                         } catch (Throwable jjte001) {
                                           if (jjtc001) {
                                             jjtree.clearNodeScope(jjtn001);
                                             jjtc001 = false;
                                           } else {
                                             jjtree.popNode();
                                           }
                                           if (jjte001 instanceof RuntimeException) {
                                             throw (RuntimeException)jjte001;
                                           }
                                           if (jjte001 instanceof ParseException) {
                                             throw (ParseException)jjte001;
                                           }
                                           throw (Error)jjte001;
                                         } finally {
                                           if (jjtc001) {
                                             jjtree.closeNodeScope(jjtn001,  2);
                                           }
                                         }
/*@egen*/                        ]
}

// A statement block is simply 0 or more statements.
void statement_block()      :
{}
{
	(statement())*
}

// Statement structure - has many possible routes.
// Skip token is used to skip the expection of anything else inside statement.
void statement()           :
{/*@bgen(jjtree) Statement */
  ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
 try {
/*@egen*/
	identifier() (assignmentExpression() | functionCallStatement())
	| <BEGIN>
	      statement_block() 
	  <END>
	| <IF> condition() 
	      <BEGIN>
	          statement_block()
	      <END>
	| <ELSE>
	      <BEGIN>
		      statement_block()
		  <END>
	| <WHILE> condition()
		  <BEGIN>
		      statement_block()
		  <END>
	| <SKIP_TOKEN> <SEMICOLON>/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

// Fragment definition - tied to expression definition.
// An expression can evaluate to our list of primitive tokens - 
// Minus Digit, Minus ID, Digit, True, False.
void fragment()      :
{Token t;}
{
    ((t = <MINUS>) (number() | identifier())/*@bgen(jjtree) #Minus_sign( 1) */
                                             {
                                               ASTMinus_sign jjtn001 = new ASTMinus_sign(JJTMINUS_SIGN);
                                               boolean jjtc001 = true;
                                               jjtree.openNodeScope(jjtn001);
                                             }
                                             try {
/*@egen*//*@bgen(jjtree)*/
                                             {
                                               jjtree.closeNodeScope(jjtn001,  1);
                                               jjtc001 = false;
                                             }
/*@egen*/ {jjtn001.value = t.image;}/*@bgen(jjtree)*/
                                             } finally {
                                               if (jjtc001) {
                                                 jjtree.closeNodeScope(jjtn001,  1);
                                               }
                                             }
/*@egen*/               )
    | number() | <TRUE> | <FALSE>
}

/* Expression can be a simple_expression() followed by 0 or 1 more
 * Arithmetic operators and an expression.
 */
void expression()      :
{Token t;}
{
    simple_expression() 
	[
		((t = <PLUS> | t = <MINUS> | t = <MULT> | t = <DIVIDE>) expression()/*@bgen(jjtree) #Binary_arith_op( 2) */
  {
    ASTBinary_arith_op jjtn001 = new ASTBinary_arith_op(JJTBINARY_ARITH_OP);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*//*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn001,  2);
    jjtc001 = false;
  }
/*@egen*/ 
		{jjtn001.value = t.image;}/*@bgen(jjtree)*/
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  2);
    }
  }
/*@egen*/                    )
	]
}

/* A simple expression defines either:
 * 1) A fragment as previously defined.
 * 2) An expression with a Left parenthese and Right parenthese surrounding.
 * 3) An ID followed by 0 or 1 Left parenthese + argument list + right parenthese.
 */
void simple_expression()     :
{/*@bgen(jjtree) Exp */
  ASTExp jjtn000 = new ASTExp(JJTEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Exp */
    try {
/*@egen*/
    <LBRACE> expression() <RBRACE>
    | identifier() [<LBRACE> arg_list() <RBRACE>]
    | fragment()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

// A condition firstly can be instantiated with either a not token (~ tilde) or not.
// Following is a simple condition with 0 or 1 logical operators followed by a condition.
// Structure is very similar to expression() above but with the NOT token.
void condition()      :
{}
{   
    [<NOT>] simple_condition() [<BOOL_OP> condition()]
}

/* A simple condition takes a left bracket, condition, right bracket or
 * It takes a special_expression followed by 0 or 1 comparison operators and another
 * expression.
 * The special_expression is necessary for allowing the parser to have no difficulty,
 * when deciding what choice to make in our parser.
*/
void simple_condition()      :
{}
{   
    <LBRACE> condition() <RBRACE> 
    | special_expression() comp_op() expression()
}

// Special Expression structure - similar to expression / condition.
void special_expression()      :
{Token t;}
{
    simple_special_expression() 
	[
		((t = <PLUS> | t = <MINUS> | t = <MULT> | t = <DIVIDE>) special_expression()/*@bgen(jjtree) #Binary_arith_op( 2) */
  {
    ASTBinary_arith_op jjtn001 = new ASTBinary_arith_op(JJTBINARY_ARITH_OP);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*//*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn001,  2);
    jjtc001 = false;
  }
/*@egen*/ 
		{jjtn001.value = t.image;}/*@bgen(jjtree)*/
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  2);
    }
  }
/*@egen*/                    )
	]
}

// Similar to simple_expression, but without the <LBRACE> choice conflict.
void simple_special_expression()      :
{}
{
    <ID> [<LBRACE> arg_list() <RBRACE>]
    | fragment()
}

// Argument list is 0 or 1 non-empty argument lists.
void arg_list()      :
{}
{
    [nemp_arg_list()]
}

// Non-empty argument list, is a list of IDs with COMMAs separating them.
void nemp_arg_list()      :
{}
{
    identifier() [<COMMA> nemp_arg_list()]
}

void assignmentExpression()                :
{/*@bgen(jjtree) Assignment_exp */
 ASTAssignment_exp jjtn000 = new ASTAssignment_exp(JJTASSIGNMENT_EXP);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Assignment_exp */
  try {
/*@egen*/
  t = <ASSIGNMENT> expression() <SEMICOLON>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void functionCallStatement()                         :
{/*@bgen(jjtree) Function_call_statement */
 ASTFunction_call_statement jjtn000 = new ASTFunction_call_statement(JJTFUNCTION_CALL_STATEMENT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Function_call_statement */
  try {
/*@egen*/
  t = <LBRACE> arg_list() <RBRACE> <SEMICOLON>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// List of our comparison operator tokens.
void comp_op()      :
{}
{
    <EQUALS> | <NOT_EQUALS> | <LESS_THAN> | <LESS_THAN_OR_EQUAL>
    | <GREATER_THAN> | <GREATER_THAN_OR_EQUAL>
}

void number(): 
{/*@bgen(jjtree) number */
 ASTnumber jjtn000 = new ASTnumber(JJTNUMBER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) number */
 try {
/*@egen*/
	t = <DIGIT>/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ {jjtn000.value = t.image;}/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

String identifier(): 
{/*@bgen(jjtree) identifier */
 ASTidentifier jjtn000 = new ASTidentifier(JJTIDENTIFIER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) identifier */
 try {
/*@egen*/
	t = <ID>/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/ {jjtn000.value = t.image; return t.image;}/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

// Defines the type for AST matching.
void anyType():
{/*@bgen(jjtree) anyType */
 ASTanyType jjtn000 = new ASTanyType(JJTANYTYPE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) anyType */
 try {
/*@egen*/
	(t = <VOID> | t = <INTEGER> | t = <BOOLEAN>)/*@bgen(jjtree)*/
                                              {
                                                jjtree.closeNodeScope(jjtn000, true);
                                                jjtc000 = false;
                                              }
/*@egen*/ {jjtn000.value = t.image;}/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void typeInteger():
{/*@bgen(jjtree) typeInteger */
 ASTtypeInteger jjtn000 = new ASTtypeInteger(JJTTYPEINTEGER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) typeInteger */
 try {
/*@egen*/
	t = <INTEGER>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/ {jjtn000.value = t.image;}/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void typeBoolean():
{/*@bgen(jjtree) typeBoolean */
 ASTtypeBoolean jjtn000 = new ASTtypeBoolean(JJTTYPEBOOLEAN);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) typeBoolean */
 try {
/*@egen*/
	t = <BOOLEAN>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/ {jjtn000.value = t.image;}/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

// Our main function definition.
void main()      :
{/*@bgen(jjtree) Main */
  ASTMain jjtn000 = new ASTMain(JJTMAIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Main */
 try {
/*@egen*/
	<MAIN>
		<BEGIN> 
			[dec_list()] 
			(/*@bgen(jjtree) Statement_block */
    {
      ASTStatement_block jjtn001 = new ASTStatement_block(JJTSTATEMENT_BLOCK);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/statement_block()/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/                 ) 
		<END>/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}